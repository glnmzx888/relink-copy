finalizer queries don't work for ibm vms. null the finalizer queries don't work for ibm vms and have a problem with sun vms as 1.the finalizer thread is called &quot;finalizer thread&quot; 2.the finalizer thread is a java.lang.thread 3.on ibm java 5 &amp; 6 vms, the objects to be finalized are not on the java.lang.ref.finalizer queue. instead they are marked as gc roots of type finalizable. the order that these objects will be finalized is not known. 4.on ibm java 5 &amp; 6 vms, the object being finalized is not a referent of a java.lang.ref.finalizer local variable. instead it is a local variable of the finalizer thread, but it is not known which, so all local variables of the finalizer thread should be returned as possible finalizer objects in processing. 5.with sun vms calling system.runfinalization() causes the creation of an extra thread of type java.lang.thread, name &quot;secondary finalizer&quot; to do the finalization. the current queries don't allow for this thread, or multiple finalizer threads in general. if runfinalization is called by several threads at once or from a finalizer then several &quot;secondary finalizer&quot; threads will be active at once.  i have a patch that separates the finding of the finalizer threads, and fixes the finalizerqueuequery and the finalizerinprocessing query. created <span class=""><a href="attachment.cgi?id=118887&amp;action=diff" name="attach_118887" title="patch for multiple finalizer threads + ibm/sun differences">attachment 118887</a> <a href="attachment.cgi?id=118887&amp;action=edit" title="patch for multiple finalizer threads + ibm/sun differences">[details]</a></span> patch for multiple finalizer threads + ibm/sun differences  sun vms can have multiple finalizer threads, so this patch isolates finding the  threads to one place, and also allows the code to find the ibm finalizer thread.  the ibm  and 6 vms don't use the finalizer ref queue, so use the heap roots to get the finalizer queue (we don't get the order however).  the finalizers being processed in an ibm vm don't have a finalizer ref object, so the only thing to do is to indicate all local objects as possible objects being finalizer. hi andrew,  thanks a lot for the patch. and i apologize for the long time without response to you. i have tried the patch with dtfj dumps from ibm i, aix and plinux and it worked fine on all of them. so i will submit your changes.  i have one more suggestion, and wanted to get your opinion on it. the list of objects to be finalized is cut to 25, and normally there are thousands of object in the list. so i wanted to add a histogram of all objects to be finalized. thus the one doing the analysis will have a much better overview of what’s in the queue. for sun vms, we would like to keep the object list also, as it shows the order of the objects. for the ibm vms we can’t get the order, so i was wondering if i should remove the list there and show only the histogram. what is your opinion?  regards, krum for the ibm  and 6 vms there is no order, so the histogram would have all the information.  i think the ibm .2 vms do use the finalizer ref queue, so i would say then do both.  i.e. always show the histogram and if there is a finalizer ref queue, show the list as well. hi andrew,  today i came accross some change which the patch introduced, but i think is undesired. in the finalizerinprocessingquery if there is no java.lang.ref.finalizer you added all java locals. when i ran this on an hprof dump, where there was no activity by the finalizer, it showed me tree objects as currently being processed - the thread itself, the reference queue and the queue lock. i think this is somewhat misleading. so i added some checks to exclude these objects specifically:  for (iobject object : localvars) {    if ((object.getobjectid() != i) // shouldn't be the finalizer thread itself     &amp;&amp; !object.getclazz().getname().equals(&quot;java.lang.ref.referencequeue&quot;) // exclude the queue also     &amp;&amp; !object.getclazz().getname().equals(&quot;java.lang.ref.referencequeue$lock&quot;)) // exclude also the queue lock {     result.add(object.getobjectid()); } }  is it possible to run into similar situation with ibm dumps? do you have for me some further class names which i should exclude?  regards, krum hi andrew,  i applied your patch, made the change we discussed and committed them together - revision 279 in svn.  i complete the message now. thanks again for the contribution.  greets, krum (v ms ) (v ms ) (v ms ) (v ms ) (v ms ) (v ms ) (finalizer queue query ) (finalizer in processing ) (v ms ) (v ms ) (v ms ) (v ms ) (v ms ) (v ms ) (finalizer in processing query ) (i object ) (reference queue ) (reference queue ) 255510 255510 255510 255510