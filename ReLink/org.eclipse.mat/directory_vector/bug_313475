new gc root types make paths from gc roots and dominator tree less expressive. null as discussed in the forum [1] there are certain gc root types which the paths from gc roots query should ignore. an example of such root is unfinalized. having the query end the path at such object makes it difficult to see the &quot;real&quot; gc roots, e.g. the real reason for the object to be kept. we should define which gc root types can be ignored and try to change the implementation of the query.  [1] <a href="http://www.eclipse.org/forums/index.php?t=msg&amp;th=168323&amp;start=0">http://www.eclipse.org/forums/index.php?t=msg&amp;th=168323&amp;start=0</a>&amp; this issue is a major problem which has stopped me from using  entirely.   i've been trying to use mat  for the majority of my memory work, but it is giving me problems in how, i assume, it is creating the dominator tree. in , many, many more things appear to be their own gc root. if i load up the same dump in , i get much more useful information. how has the creation of the dominator tree/gc roots determination changed from  to ? i'm finding that  is almost useless because of this issue. i think both problems are related and we should have some discussion in this bug how to solve several problems - to get only the real gc roots as gc roots again - to attach some special semantic to certain objects (like the unfinalized...) - what are use cases where it is really necessary that the paths from gc roots go through the gc root nodes  i am changing the short description of the bug accordingly. dtfj roots of type unfinalizedobject are not marked as roots because they are just weak roots.  however, there is some code that if finalizable objects (object on the finalizer queue) are not found via dtfj then they are created as roots by looking for objects with a finalize method where the objects are unreferenced. some extra code also marked referenced objects which could be finalized later as unfinalized. this created the spurious gc roots.  the fix is to only mark those objects if the skipweakroots flag is false.  we can consider whether to tag unfinalized objects or other weak roots in some other way which doesn't break paths to gc roots.  also having the boot loader as a source for the roots is confusing. (in reply to <a href="show_bug.cgi?id=313475#c2">comment #2</a>) <span class="quote">&gt; - what are use cases where it is really necessary that the paths from gc roots &gt; go through the gc root nodes</span >  hi krum,   i use the tool for two main use cases (and they are strongly related)    our product has hit an oome, and i need to figure out the cause.   our product is using more memory then we think it should for a particular scenario, and i want to understand how to use less memory.  to me the most important function, is a way to understand what is keeping stuff in memory, so that i can make the right changes so that we use less memory. any false hits, just make my task harder, and are a distraction. i've stopped unfinalizedobjects being roots (unless skipweakroots flag is false.)  i've stopped the boot loader being a source for roots, except for system classes.  if we need to mark objects as weak roots (e.g. if they are tagged, but not treated as roots), then that can be handled with another enhancement. (unfinalized object ) (unfinalized objects ) ( c ) ( 2 ) 313475 313475 313475 313475