wrong sizes reported for instances with a single byte field. null steps to reproduce: the size of classes with one byte field is incorrectly reported, when inheritance is used.    more information: given :  3 classes a,b,c, a a super class of b and b a super class of c. each class contains one field of type byte.  the memory analyzer reports that this consumes 40 bytes but in reality it does only consume 24 bytes on a 32 bit windows sun jvm (jdk ).  this can be verified for example with yourkit doing a heap dump with the profiling api.     regards, markus hi markus,  i'll have to dig into this one. as of jdk , the vm does align any class to 8 bytes. this also occurs during inheritance. the behavior you describe is actually implemented on purpose. i will check if this changed with jdk 6. thanks for the report.  andreas. the hprof parser calculates the size of an instance by summing the sizes of fields declared in each class with the calculated instance size of superclass calculated recursively and rounds them up to an 8 byte boundary.  the final instance size should be rounded up to an 8 byte boundary, but possibly not at all the intermediate stages as the vm may be able to use padding space in a superclass for some of a subclasses fields. the precise rules are going to be vm specific.  e.g. instead of this:  class a - size 16  0: header1  4: header2  8: field1 12: pad1  class b extends a - size 24  0: header1  4: header2  8: field1 12: pad1 16: field2 20: pad2  class c extends b - size 32  0: header1  4: header2  8: field1 12: pad1 16: field2 20: pad2 24: field3 28: pad3  the sizes might be as follows:  class a - size 16  0: header1  4: header2  8: field1 12: pad1  class b extends a - size 16  0: header1  4: header2  8: field1 12: field2  class c extends b - size 24  0: header1  4: header2  8: field1 12: field2 16: field3 20: pad2  i did some tests with sun jdks 6 update 16 and the following classes:  public class classa {     byte field1 = 1; }  public class classb extends classa {     byte field2 = 2; }  public class classc extends classb {     byte field3 = 3; }  i ran a simple program creating one instance of each, and then compared the results from the class histogram (printed from the vm because of the option -xx:+printclasshistogram) and results from mat. i did this for 32 and 64 bit vms, and also for 64 bit vm with option for compressed oops.  here the results from the comparison:  jdk 6_16, x32 class name| histogram | mat           ------------------------------------ classc    |        24 |           32  classb    |        16 |           24  classa    |        16 |           16  ------------------------------------  jdk 6_16, x64 class name| histogram | mat           ------------------------------------ classc    |        40 |           40                 classb    |        32 |           32                 classa    |        24 |           24                 ------------------------------------  jdk 6_16, x64, -xx:+usecompressedoops class name| histogram | mat           ------------------------------------ classc    |        24 |           40                 classb    |        24 |           32                 classa    |        16 |           24                 ------------------------------------  we have to look into more details how to guess the right size. in the past we did the alignment to 8 because the sizes reported in the .hprof dump were (and probably still are) without the alignment. however as this gets very vm (and even parameter) specific we should think of a more reliable way to compute the sizes when inheritance comes into play.  andrew, can we get some similar comparison from an list of ibm vms? for an ibm vm:  java version &quot;.0&quot; java(tm) se runtime environment (build pwi3260sr6-20090925_01(sr ) ibm j9 vm (build , jre .0 ibm j9  windows xp x86-32 jvmwi3260sr6-20090923_42924 (jit enabled, aot enabled) j9vm - 20090923_042924 jit  - r9_20090902_1330ifx1 gc   - 20090817_aa) jcl  - 20090924_01  used mem calculated at run time by allocating objects and measuring total and free memory.   class name| used mem  | mat           ------------------------------------ classc    |        24 |           24                 classb    |        24 |           24                 classa    |        16 |           16                 ------------------------------------  the sizes come from dtfj - so the dtfj adapter doesn't have to calculate that. the sizes for 32-bit sun vms appear to be calculated by rounding superclass sizes to 4 bytes, then adding the fields, then rounding the whole calculation to 8 bytes. the header is 2*4 bytes this works well for a dump i tried.  the sizes for 64-bit sun vms appear to rely on rounding superclass sizes to 8 bytes, adding fields, then rounding to 8. the header is 2*8 bytes.  the sizes for 64-bit sun vms appear to be calculated by rounding superclass sizes to 4 bytes, then adding the fields, then rounding the whole calculation to 8 bytes. the header is 3*4 bytes.  there's not enough data to be sure about the last two.  what should shapshotinfo.getidentifiersize return for a 64-bit compressed pointer dump? perhaps 64-bit would be less confusing when displayed to the user.  the javadoc says: int org.eclipse.mat.snapshot.snapshotinfo.getidentifiersize() get size of the internal identifiers in the heap dump, i.e. 32 or 64 bit.   returns: size of the internal identifiers in the heap dump, i.e. 32 or 64 bit  but it seems this size is actually the number of bytes, 4 or 8. i played a little bit today with heap dumps from x64 sun vm, both with and without compressed oops. i was hoping to be able to determine the difference from the hprof file, but i failed. the reported id size is in both cases x64, and the reported sizes in the class_dump records are also the same. we ignore these sizes anyway, as they do not include the header size and are not aligned in any way, but i was hoping to see there some difference and use it as an indicator that the pointers are compressed. no success.  therefore we will continue to show the sizes as for the x64 bit without compression case. at least until we find a way to distinguish between them.  about the x32 size i will try to come up with a fix in the next days. andrew's observation were very helpful. i'm just double-checking with some colleagues. i made a fix (revision  , following the suggestion from andrew - for x32 sun superclass sizes are aligned to 4 and the end result aligned to 8.  i added some tests (org.eclipse.mat.tests.snapshot.testinstancesizes) which compare the sizes reported in a histogram against the ones we produce in mat.  for a jdk 6 x64 the tests are ok. for a jdk 6 x32 the tests are ok. for a jdk 5 x32 the tests were mostly ok. the example described above (classa, classb, classc) was tested ok, i.e. the sizes were matching the ones from the histogram. there were some exceptions however, where after looking in detail i have no idea where the difference comes from. these are classes directly extending java.lang.object. and summing the fields i get 8 bytes less. we are guessing that there could be some internal data attached to these (probably special objects), which is not provided in the heap dump. this is the failure list (i removed then these lines from the test histogram, so that our tests are ok):  class [java.lang.thread] expected size 96 but got 88 class [java.util.jar.jarfile$jarfileentry] expected size 96 but got 88 class [java.util.zip.inflater] expected size 40 but got 32 class [java.lang.ref.reference$referencehandler] expected size 96 but got 88 class [java.lang.ref.finalizer$finalizerthread] expected size 96 but got 88 class [java.io.expiringcache] expected size 40 but got 32 class [java.util.random] expected size 32 but got 24  with these modifications i'd like to close this bug. the summary:  - sizes from 64 bit vms are ok.  - now we have correct sizes for java 6, and as correct as possible sizes for java 5, java  wasn't tested (i assume there it is now wrong, as initially i have used  as a sample) - for the special case of a x64 sund vm with compressed oops we have no solution. there is no way to guess from the hprof file that the pointers were compressed (jd ks ) (print class histogram ) (v ms ) (use compressed oops ) (v ms ) (v ms ) (v ms ) (v ms ) (shapshot info ) (snapshot info ) (test instance sizes ) (jar file ) (jar file entry ) (reference handler ) (finalizer thread ) (expiring cache ) (v ms ) (oo ps ) ( header ) ( 1 ) ( header ) ( 2 ) ( field ) ( 1 ) ( pad ) ( 1 ) ( header ) ( 1 ) ( header ) ( 2 ) ( field ) ( 1 ) ( pad ) ( 1 ) ( field ) ( 2 ) ( pad ) ( 2 ) ( header ) ( 1 ) ( header ) ( 2 ) ( field ) ( 1 ) ( pad ) ( 1 ) ( field ) ( 2 ) ( pad ) ( 2 ) ( field ) ( 3 ) ( pad ) ( 3 ) ( header ) ( 1 ) ( header ) ( 2 ) ( field ) ( 1 ) ( pad ) ( 1 ) ( header ) ( 1 ) ( header ) ( 2 ) ( field ) ( 1 ) ( field ) ( 2 ) ( header ) ( 1 ) ( header ) ( 2 ) ( field ) ( 1 ) ( field ) ( 2 ) ( field ) ( 3 ) ( pad ) ( 2 ) ( field ) ( 1 ) ( field ) ( 2 ) ( field ) ( 3 ) ( x ) ( 32 ) ( x ) ( 64 ) ( x ) ( 64 ) ( sr ) ( 6 ) ( j ) ( 9 ) ( j ) ( 9 ) ( x ) ( 86 ) ( r ) ( 9 ) ( x ) ( 64 ) ( x ) ( 64 ) ( x ) ( 64 ) ( x ) ( 32 ) ( x ) ( 32 ) ( x ) ( 64 ) ( x ) ( 32 ) ( x ) ( 32 ) ( x ) ( 64 ) 231296 231296 231296 231296