nullpointerexception on some reports on phd dump. null i have a reasonably large (private, sorry) .phd dump loaded using:  com.ibm.dtfj.feature_..jar org.eclipse.mat.ibmvm.feature_..jar  into:  org.eclipse.mat.jdt_..jar.  this needs of the order of -xmx5g to complete the parse, and eclipse has oomed at least once while browsing the results.  the below happen before this oom would occur (e.g. the &quot;used&quot; heap never passes 4gb even with -xmx7g).  many of the functions work fine (as far as i can tell) (heap dump overview, leak suspects, dominator tree, etc.), but top components:   java.lang.nullpointerexception     at org.eclipse.mat.inspections.component.componentreportquery.addsoftreferencestatistic(componentreportquery.java:      at org.eclipse.mat.inspections.component.componentreportquery.execute(componentreportquery.java:      at org.eclipse.mat.query.registry.argumentset.execute(argumentset.java:      at org.eclipse.mat.snapshot.query.snapshotquery.execute(snapshotquery.java:      at org.eclipse.mat.inspections.component.topcomponentsreportquery.execute(topcomponentsreportquery.java:      at org.eclipse.mat.query.registry.argumentset.execute(argumentset.java:      at org.eclipse.mat.query.registry.commandline.execute(commandline.java:      at org.eclipse.mat.report.internal.querypart.execute(querypart.java:      at org.eclipse.mat.report.testsuite.execute(testsuite.java:      at org.eclipse.mat.report.internal.runregisterdreport.execute(runregisterdreport.java:      at org.eclipse.mat.query.registry.argumentset.execute(argumentset.java:      at org.eclipse.mat.ui.queryexecution$executionjob.run(queryexecution.java:      at org.eclipse.core.internal.jobs.worker.run(worker.java:     ...and finalizer references statistics:  java.lang.nullpointerexception     at org.eclipse.mat.inspections.referencequery.execute(referencequery.java:      at org.eclipse.mat.inspections.finalizerreferencestatquery.execute(finalizerreferencestatquery.java:      at org.eclipse.mat.query.registry.argumentset.execute(argumentset.java:      at org.eclipse.mat.ui.queryexecution$executionjob.run(queryexecution.java:      at org.eclipse.core.internal.jobs.worker.run(worker.java:    ... npe quickly.    heap dump details: format: j2re .2 ibm aix 5l for powerpc (64 bit jvm) build... identifier size: 64-bit file length: m. heap: ~gb number of object: &gt;33m. number of classes: ~2k number of class loaders: 20 number of gcroots: ~14k.  eclipse: eclipse.buildid=i20081211-1908 java.version=.0_12 java.vendor=sun microsystems inc. bootloader constants: os=win32, arch=x86_64, ws=win32, nl=en_gb command-line arguments:  -os win32 -ws win32 -arch x86_64 phd files don't have any field information. the both problems are caused by using a getfield without testing for null. this could occur in other places too. created <span class="bz_obsolete"><a href="attachment.cgi?id=127015&amp;action=diff" name="attach_127015" title="isolate getting a referent field">attachment 127015</a> <a href="attachment.cgi?id=127015&amp;action=edit" title="isolate getting a referent field">[details]</a></span> isolate getting a referent field  this patch shows how to isolate getting a referent field. it also guesses a referent field from outbound references for a java.lang.ref.reference if the field is not found (e.g. phd files).  there are some other getfields to be fixed, notably in the finalizer queries. the finalizer queries also need to be updated for ibm vms - see another defect. andrew,  together with carmine, i added the following code to the weak reference, finalizer queries etc etc. so actually, the &quot;old&quot; phd adapter should never allow the execution of this code.          inspectionassert.heapformatisnot(snapshot, &quot;phd&quot;);  it looks like, now we only now it is dtfj (because phd is read via dtfj). so we are back to square one a/b this discussion:  a) define a format/subformat pair which can be queried to decided how to do finalizer (&quot;dtfj&quot;/&quot;phd&quot; or &quot;hprof&quot;/&quot;sun&quot;). this actually relates to the other open issue a/b having multiple elements in the parser definition. essentially those could be the sub elements? b) have the capabilities with the snapshot (&quot;hasfieldvalues&quot;) and have the queries ask for those properties  i tend to go for (a). what are your thoughs on this?  andreas. each different implementation of dtfj now has a different mat heap format.  the type is defined in the dtfj implementation and is converted by the dtfj adapter into an mat heap format with a separate parser element. the current formats are:  dtfj-j9 dtfj-javacore dtfj-sdff dtfj-phd  dtfj-phd files don't have field information or primitive field/array values, though they do have outbound references.  dtfj-javacore files have very limited information - only classes and class loaders.  i think the first step is to check all the getfields() for null returns, and to use something like my patch for the referent fields.  the finalizer queries could be fixed in a similar way, but there is another bug open with patch about getting them to work with ibm dumps. i didn't want to give a patch on a patch.  only if the query is completely bogus is it worth totally disabling the query for a dump type  the dump type (e.g. dtfj-phd) is not a good way of telling implementation specific parts of a vm dump, as ibm .2,  and 6 vms can all generate dtfj-phd dumps.  i've cancelled the multiple parser element bug as i do not now need it. a/b the heap format...  i understand your solution via the dynamic bindings now. you are right, it is not urgent to change something. nevertheless, with the heap dump, i only store the unique identifier of the extension to be able to re-create the object reader. as long as one and the same id (&quot;dtfj-phd&quot; shows up tow times) has the same reader implementation, id does not hurt.   a/b your patch reading the reference field...  if i understand you correctly, if you do not find any field names, you simply take the second outgoing reference (the first one is the &lt;class&gt; reference). this is where i am hesitating a little bit. the second reference could the &quot;referent&quot;, but maybe also the &quot;queue&quot;, &quot;next&quot; or &quot;discovered&quot;. and this is just talking about sun's current implementation. any thoughts? does it work for your phd dumps? i tried running the following query on my dump:   select w.getoutboundreferences() from instanceof java.lang.ref.weakreference w where (w.getoutboundreferences().size()&gt;=  and it does not return any results. i checked the coding, and this is due to the fact that the heap object reader does not fill the &quot;fields&quot; field of the instance.  i also discovered, that in the phd dump i have on my computer, weakreference and softreference do not extend java.lang.ref.reference, but java.lang.object. any idea? you have added the check (obj.getclazz().doesextend(&quot;java.lang.ref.reference&quot;)) but this check would not really help.  maybe my version is too old? i was using org.eclipse.mat.dtfj_..jar   on the other hand, the global &quot;it won't work and i don't even try&quot;-approach of not running the query for phd (which didn't work anymore because the id changed) is not good either. <span class="quote">&gt;in the phd dump i have on my computer, weakreference and softreference do not extend java.lang.ref.reference</span >  some phd dumps (e.g. ibm java ) do not have superclass information, so the doesextend test is not reliable. we could also test the name against each of the reference types (or regex &quot;java\.util.\.*reference&quot; and perhaps java.util.ref.finalizer).  the idea of taking the second reference as the referent isn't good. phd dumps omit null references, so if the referent is null we would get another field.  we could skip outbound references to reference types or reference queues, then if something was left presume it was the referent.  your are right about the getoutboundreferences. i was thinking of    obj.getsnapshot().getoutboundreferentids(obj.getobjectid());  is there a problem with phd dumps having getoutboundreferentids() but not getoutboundreferences()? inventing field names for getoutboundreferences() seems bogus, especially as the field names would not correspond between different objects of the same type as null fields are omitted.  (in reply to <a href="show_bug.cgi?id=266231#c6">comment #6</a>) <span class="quote">&gt; your are right about the getoutboundreferences. i was thinking of &gt;    obj.getsnapshot().getoutboundreferentids(obj.getobjectid());</span >  if you do this, then you cannot make any assumption about the order of the outbounds. null values do not show up. only actual outgoing references. (i think it is not re-ordered though, but inbounds are ordered ascending by object id).  <span class="quote">&gt; we could skip outbound references to reference types or reference queues, then &gt; if something was left presume it was the referent.</span >  that surely is one possibility. i ran the following oql: select objects outbounds(w) from java.lang.ref.weakreference w and grouped the result as a class histogram.  this created the following for  weak references.  class name                                                  | objects | ----------------------------------------------------------------------- java.lang.class                                             |   | java.lang.ref.referencequeue                                |    | ....others....                                              |   | -----------------------------------------------------------------------                                                                  the query does not use the distinct keyword! interesting, i get more classes than weak references, which means the class types are referenced multiple times. i get similar results for hprof dumps ( classes references for  weak references).  what is your take on this? are the results sufficiently close to the actual data that we can live with the margin of error?  <span class="quote">&gt; is there a problem with phd dumps having getoutboundreferentids() but not &gt; getoutboundreferences()? inventing field names for getoutboundreferences() &gt; seems bogus, especially as the field names would not correspond between &gt; different objects of the same type as null fields are omitted.</span >  agreed. inventing field names is bogus. it just means that we cannot use the getoutboundreferences() to determine the n'th outbound reference. those include only named outbound references. created <span class=""><a href="attachment.cgi?id=127309&amp;action=diff" name="attach_127309" title="try to get the referent when fields do not exist">attachment 127309</a> <a href="attachment.cgi?id=127309&amp;action=edit" title="try to get the referent when fields do not exist">[details]</a></span> try to get the referent when fields do not exist  this patch isolates getting the referent of a reference. if the field is found then it is used.  if it is not found, then if the object appears to be of type reference or finalizer (via checking the type, supertype or name) then we look at all the outbound referent ids. we then exclude the type of the object, and what might be link or queue fields pointing to other references or queues. out of curiosity, i wrote a little query to compare the actual referent with the one determined by the getreferent method. (see attachment) i did run it on a variety of hprof dumps which contain the referent field and therefore allow me to compare. i looked at 5 dumps:  [1] dump        dump04 pid775  710    pid14882 oom  [2] size        3,3gb  1,8gb   0,3gb  2,5gb    2,5gb  [3] references  88389  108343  70462  103726   25082 [4] success       76%     75%    69%     67%     69%  [5] only jdk    49880   60154  28020    7742   13122 [6] success      100%    100%   100%    100%    100%  [7] % jdk refs    56%     56%    40%      7%     52%   first [1] line contains my test dumps, don't bother with the names and[2] is the size of the hprof file.  [3] and [4] show the total number of objects extending java.lang.ref.reference and the success rate in trying to guess the referent field.  [5] and [6] show the same, but this time only for classes that match the following pattern (&quot;jdk refs&quot;): &quot;java\\.lang\\.ref\\..*reference&quot; or &quot;java.lang.ref.finalizer&quot;.  [7] shows the ratio of jdk references : all references.   in summary, guessing the referent for jdk references works perfectly. however, those make up only between 7% to 56% depending on the use case. guessing the referent for all references shows a high margin of error - somewhere between 33% and 24%.   right now i tend to opt for the following option:  * guess the referent only for jdk classes * add indicator to the title that this contains only partial results (e.g. &quot;... (only jdk references)&quot;) * do not show wrong results (e.g. rather show nothing for the non jdk references)   what do you think about this? created <span class=""><a href="attachment.cgi?id=127333" name="attach_127333" title="query to check java.lang.ref.reference guessing">attachment 127333</a> <a href="attachment.cgi?id=127333&amp;action=edit" title="query to check java.lang.ref.reference guessing">[details]</a></span> query to check java.lang.ref.reference guessing your idea sounds good. created <span class=""><a href="attachment.cgi?id=128181&amp;action=diff" name="attach_128181" title="guess referent according to cooment #9">attachment 128181</a> <a href="attachment.cgi?id=128181&amp;action=edit" title="guess referent according to cooment #9">[details]</a></span> guess referent according to cooment #9  hi andrew,  i have updated the coding. i tested it on my dumps. can you do me the favour and do a quick (code) review of the patch?  andreas. the fix looks good.  the comment  +     * important: the &lt;strong&gt;classname&lt;/strong&gt; must point to +     * java.lang.ref.reference or one of its subclasses. we cannot check this, +     * because  isn't quite complete and i don't see the immediate relevance of the opensnapshot.java and snapshotfactoryimpl.java changes, but they look harmless. hi andrew,  you're right a/b opensnapshot/snapshotfactoryimpl - it's purpose was to sort the heap formats in the drop-down box alphabetical.  i have committed the patch.  andreas. comment on <span class=""><a href="attachment.cgi?id=127309&amp;action=diff" name="attach_127309" title="try to get the referent when fields do not exist">attachment 127309</a> <a href="attachment.cgi?id=127309&amp;action=edit" title="try to get the referent when fields do not exist">[details]</a></span> try to get the referent when fields do not exist  basis for patch (null pointer exception ) (oo med ) (null pointer exception ) (component report query ) (component report query ) (component report query ) (component report query ) (argument set ) (argument set ) (snapshot query ) (snapshot query ) (top components report query ) (top components report query ) (argument set ) (argument set ) (command line ) (command line ) (query part ) (query part ) (test suite ) (test suite ) (run registerd report ) (run registerd report ) (argument set ) (argument set ) (query execution ) (execution job ) (query execution ) (null pointer exception ) (reference query ) (reference query ) (finalizer reference stat query ) (finalizer reference stat query ) (argument set ) (argument set ) (query execution ) (execution job ) (query execution ) (power pc ) (gc roots ) (boot loader ) (v ms ) (inspection assert ) (v ms ) (weak reference ) (weak reference ) (soft reference ) (weak reference ) (soft reference ) (weak reference ) (reference queue ) (open snapshot ) (snapshot factory impl ) (open snapshot ) (snapshot factory impl ) ( i ) ( 20081211 ) ( win ) ( 32 ) ( x ) ( 86 ) ( win ) ( 32 ) ( win ) ( 32 ) ( win ) ( 32 ) ( x ) ( 86 ) ( j ) ( 9 ) ( c ) ( 6 ) ( dump ) ( 04 ) ( pid ) ( 775 ) ( pid ) ( 14882 ) 266231 266231 266231 266231