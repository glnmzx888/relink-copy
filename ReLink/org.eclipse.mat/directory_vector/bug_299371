mat api changes for . null the  release which we are planning is a good point to look again at the apis provided by mat and reconsider if some modifications are necessary.   let us use this message to discuss and track what changes need to be/are done to mat api for the  release.  as a basis i have  collected some info about the currently exported packages and the public classes/methods inside. i have attached it as a csv file.  the summary of it is: bundle        /    exposed method count org.eclipse.mat.report        476 org.eclipse.mat.api        400 org.eclipse.mat.parser    275 org.eclipse.mat.hprof        2 org.eclipse.mat.chart    0 org.eclipse.mat.chart.ui    0 org.eclipse.mat.dtfj    0 org.eclipse.mat.jdt    0 org.eclipse.mat.tests    0 org.eclipse.mat.ui    0 org.eclipse.mat.ui.help    0 org.eclipse.mat.ui.rcp    0 created <span class=""><a href="attachment.cgi?id=155860" name="attach_155860" title="methods exposed as api in mat ">attachment 155860</a> <a href="attachment.cgi?id=155860&amp;action=edit" title="methods exposed as api in mat ">[details]</a></span> methods exposed as api in mat  some time ago andrew has suggested that it will be useful to have a method in the isnapshot for getting the reachable set of an object. shall we add this to the api? should istackframe.getlocalobjectsids() return null or an empty array?  is there a meaningful difference between those? an empty array might be easier for users. currently the istackframe.getlocalobjectsids() will return a null if there are no local objects. the implementation is in threadstackhelper.buildframes(). i think i left it null to avoid creating the empty arrays. however, you are right that using the api will be easier if an empty array is returned (one if statement less). in any case we have to describe the return values in javadoc. i just created another message to track this - <span class="bz_closed"><a href="show_bug.cgi?id=301664" title="resolved fixed - add javadoc to istackframe and ithreadstack">bug 301664</a></span>. objectreference has a field     private transient isnapshot snapshot;  which will never be initialized after deserialization. is this a problem? the reachable set could be used for weakhashmap problems - finding if referent is also strongly reachable from the map or key.  the reachable set could be done from a set of objects, not just a single object. the api therefore should be like the retained set query, with the exclusions.  it would also be good to have a general paths computer, from one set of objectids to another. this also should have exclusions.  way of specifying exclusions: retained set: field names (for any object?) - quite general, possibly slow as fields need to be retrieved for every object in path  retained set: excludedreferencesdescriptor[] has list of objectids and field names to exclude - could filter on objectids quickly, overridden field names can't be separated.  gcroots computer map&lt;iclass, set&lt;string&gt;&gt; - quick to find objects to exclude as just a small set of classes - so go from object to class to see if class extends excluded class. can overridden field names be separated? i.e. is the field name in the specified class? this doesn't allow a subset of instances of a class to be excluded. (in reply to <a href="show_bug.cgi?id=299371#c6">comment #6</a>) <span class="quote">&gt; the reachable set could be used for weakhashmap problems - finding if referent &gt; is also strongly reachable from the map or key. &gt;  &gt; the reachable set could be done from a set of objects, not just a single &gt; object. the api therefore should be like the retained set query, with the &gt; exclusions. &gt;  &gt; it would also be good to have a general paths computer, from one set of &gt; objectids to another. this also should have exclusions. &gt; </span > it can also be useful to have inclusions, not exclusions. e.g. for a linked list, the reachable set of type of node gives you all of the nodes. isnapshot.getheapsize() should be able to handle very large arrays. whats the reason for the  fielddescriptor.setname() fielddescriptor.settype()  methods? should fielddescriptor be unmodifiable? the only reason for  field.setvalue  seems to be so that the objectreference from a deserialized static field can be replaced by one with a reference to the current snapshot. is that the cleanest way? i haven't found any usages of  fielddescriptor.setname() fielddescriptor.settype() i guess we can either remove them or make them protected and just check if our tests are still running.  for field.setvalue() i think we can also remove. in the only place where it is used we can simply create a new instance and replace the old one, instead of setting the value.  let us just mention the changes to fielddescriptor and field in a separate message. it is easier to get an overview of the changes later, just looking at the message titles. i've changed arrayint long firstelement() to int firstelement() long lastelement() to int lastelement()  there are no uses in the product, and the return type of long must be a bug. is there a reason that   dominatorquery.java multiplepath2gcrootsquery.java path2gcrootsquery.java showindominatorquery.java  are in the package org.eclipse.mat.snapshot.inspections, and not in a package org.eclipse.mat.inspections.snapshot or similar?  if those queries were in the org.eclipse.mat.inspections subpackage then all the queries would be in the same part of the tree (and it might be easier to separate them into a separate plug-in). (in reply to <a href="show_bug.cgi?id=299371#c12">comment #12</a>) <span class="quote">&gt; are in the package org.eclipse.mat.snapshot.inspections, and not in a package &gt; org.eclipse.mat.inspections.snapshot or similar?</span >  i think i moved some time ago, because the whole inspection package was not public at all. and below snapshot it was public.  so: no good reason -&gt; go ahead and move it to a better place. these 4 queries are directly used in the ui (org.eclipse.mat.ui plugin) - there are some specific panes for them. i would like to make their package accessible to mat.ui only. the rest of the queries we should be fully hidden. i reduced the visibility of the package to the ui only (see <span class="bz_closed"><a href="show_bug.cgi?id=309766" title="resolved fixed - hide exposed snapshot inspections">bug 309766</a></span>).  there is still a way to execute a query - the snapshotquery class. it has methods to lookup a query, set it's parameters and execute it. initially i was thinking to hide this class also. currently i think that instead of hiding it i will enrich it with a method to get the list of query arguments. then the class will have all the neccesary methods: look up a query, get the description of the arguments, set arguments and execute it. to do this i'll move argumentdescriptor to a public package.  i have to describe then that the names/arguments of the queries are not part of the api and can change, and that snapshotquery should be used with care.   do you think this is fine, or shall i rather hide the class. fully hiding it  will leave no way to interact with our queries from queries outside the api plugin. this may be sometimes needed. any comments? i did the changes from my last comment. i documented them in more detail in <span class="bz_closed"><a href="show_bug.cgi?id=309818" title="resolved fixed - improve the api for looking up a query">bug 309818</a></span> currently iclass extends iobject, whereas iclassloader extends iinstance.  iobject   iarray     iobjectarray     iprimitivearray   iinstance     iclassloader   iclass   now ibm java 6 dumps do have java objects associated with each java class, of type java.lang.class and so classes are more like instance objects (rather than arrays or their own non-instance type).  both hotspot and ibm dumps appear to have instance fields on java.lang.class.  should it be possible to see these fields with iclass.getfield() ?  examples of per-instance fields of java.lang.class, with some example value for a class:  type|  name            |   value  ----------------------------------------------------------------------- long| vmref            | 1458304  ref | classloader      | com.ibm.oti.vm.bootstrapclassloader &#64; 0xc889f0  ref | protectiondomain | null  ref | classnamestring  | null  -----------------------------------------------------------------------   should iclass extend iinstance instead of iobject? if not, should classimpl implement iinstance or extend instanceimpl? i've changed annotatedobjectdescriptor.addparamter-&gt;addparameter there are many instances of   &#64;argument(flag = &quot;none&quot;)  should the &quot;none&quot; be a constant? (in reply to <a href="show_bug.cgi?id=299371#c19">comment #19</a>) <span class="quote">&gt; there are many instances of  &gt; &#64;argument(flag = &quot;none&quot;) &gt; should the &quot;none&quot; be a constant?</span >  yes, i think it would be better to add a constant somewhere. (in reply to <a href="show_bug.cgi?id=299371#c20">comment #20</a>) <span class="quote">&gt; (in reply to <a href="show_bug.cgi?id=299371#c19">comment #19</a>) &gt; &gt; there are many instances of  &gt; &gt; &#64;argument(flag = &quot;none&quot;) &gt; &gt; should the &quot;none&quot; be a constant? &gt;  &gt; yes, i think it would be better to add a constant somewhere.</span > i've added a constant argument.unflagged used as follows:      &#64;argument(flag = argument.unflagged)  if this is acceptable as a name then i can go through and make minor changes to queries to use this instead of      &#64;argument(flag = &quot;none&quot;) and also queryregistry.fromannotation() (in reply to <a href="show_bug.cgi?id=299371#c21">comment #21</a>) <span class="quote">&gt; if this is acceptable as a name then i can go through and make minor changes to &gt; queries to use this instead of  &gt;     &#64;argument(flag = &quot;none&quot;) &gt; and also queryregistry.fromannotation()</span >  i think the name is fine. just go on and to the related changes. thanks! the  release is now published. i close this ticket. (ap is ) (i snapshot ) (i stack frame ) (i stack frame ) (thread stack helper ) (i stack frame ) (i thread stack ) (object reference ) (i snapshot ) (weak hash map ) (excluded references descriptor ) (gc roots ) (i class ) (weak hash map ) (i snapshot ) (field descriptor ) (field descriptor ) (field descriptor ) (object reference ) (field descriptor ) (field descriptor ) (field descriptor ) (array int ) (dominator query ) (show in dominator query ) (snapshot query ) (argument descriptor ) (snapshot query ) (i class ) (i object ) (i class loader ) (i instance ) (i object ) (i array ) (i object array ) (i primitive array ) (i instance ) (i class loader ) (i class ) (hot spot ) (i class ) (bootstrap class loader ) (i class ) (i instance ) (i object ) (class impl ) (i instance ) (instance impl ) (annotated object descriptor ) (query registry ) (query registry ) ( c ) ( 6 ) ( c ) ( 12 ) ( c ) ( 19 ) ( c ) ( 20 ) ( c ) ( 19 ) ( c ) ( 21 ) 299371 299371 299371 299371