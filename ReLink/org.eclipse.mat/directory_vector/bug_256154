inspector: strings with large char arrays. null find strings that retain wasteful char arrays. this helps find the common problem of a string holding onto a larger than  necessary char[] due to substring(), xml, regex, etc.  in one of my recent heaps this inspector found 16,546 strings backed by a  larger than necessary char[]. for example, the largest &quot;wasted&quot; string has  a length of 251, while it retains a char[] of length 25,546 - and it's the  only reference! that's quite a waste that's easy to fix. created <span class=""><a href="attachment.cgi?id=118504&amp;action=diff" name="attach_118504" title="code">attachment 118504</a> <a href="attachment.cgi?id=118504&amp;action=edit" title="code">[details]</a></span> code hi chris,  thanks for the patch.  i am thinking right now if this query could possibly return &quot;false positives&quot;. multiple strings could point to one and the same char[]. while each of the strings point only to some parts of the char array, the char array itself is still fully used.  andreas. hello andreas, yes it can. i thought about trying harder to weed those out but initially opted not to.   it's simple to tell if there is a single string retaining the char[] and in the case where multiple strings point to different parts of a large char[] i wanted to determine how &quot;efficiently&quot; the char[] was being shared.  now that i say it, it may make more sense to separate these two into separate inspectors. one that finds the &quot;single string&quot; pointing to large char array and another inspector that calculates the amount wasted by having multiple strings point to a shared char[]. maybe one query is enough: if a char array has 50+ chars waste, then it should show up in the list. only char arrays, that have inbound references by strings, are considered.  if multiple strings point to one char array and reduce the waste below the 50 boundary, that's fine too. copying the array to avoid the waste would probably be not efficient either. hi all, i agree that finding strings that retain too large char arrays is a good thing, also with jvm's &gt; less sharing is done and the problem is typically not as frequent anymore.   if i understand andreas correctly he proposes going backwards from char[] to strings. i think that makes sense, because it's very easy to implement and char[]'s which are referenced by more than one string can easily be discarded.  it's also very likely that the main problems are found because i dont' remember that i've seen char[] with unused areas referenced by more than one string.   one could extend it by counting all unused areas in a char, which would be clearly wasted space, but that would lead to a much more time consuming query.    i'm not sure whether counting how efficiently a char[] is shared makes sense, because you could argue that say 1000 strings, which share the same char[] are not a good thing, because 1 string sharing one char[] would be much better.   &#64;chris, i have a query that counts duplicated strings, which typically is the more severe problem. it also counts how many char[] are referenced by the strings, and therefore it also takes into account how efficient char[]'s are used.   i will submit a patch for it finally, i was searching for testers maybe chris would also like to have some fun with it.  created <span class=""><a href="attachment.cgi?id=120794&amp;action=diff" name="attach_120794" title="alternative waste char[] query">attachment 120794</a> <a href="attachment.cgi?id=120794&amp;action=edit" title="alternative waste char[] query">[details]</a></span> alternative waste char[] query  hi chris,  i found the time to adapt your query. it is now considering all inbound references to a char array. if you find the time to test, i would be happy to get your feedback.  happy holidays,  andreas. i have added the query with change list [246]... 256154 256154 256154 256154